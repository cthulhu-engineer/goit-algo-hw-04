# Аналіз алгоритмів сортування

Цей документ містить висновки порівняльного аналізу трьох алгоритмів сортування: сортування злиттям, сортування вставками та Timsort (вбудованого в Python).

## Методологія

Тести були проведені на різних наборах даних (впорядковані, зворотно впорядковані, випадкові) з використанням модулю `timeit` для вимірювання часу виконання кожного алгоритму. Розмір набору даних для тестування - `n = 10000`.

## Результати тестів

Час виконання алгоритмів сортування (в секундах):

- **Сортування вставками (Insertion Sort):**
    - На впорядкованих даних: 0.00072
    - На зворотно впорядкованих даних: 2.48064
    - На випадкових даних: 1.25090

- **Сортування злиттям (Merge Sort):**
    - На впорядкованих даних: 0.01003
    - На зворотно впорядкованих даних: 0.01008
    - На випадкових даних: 0.01231

- **Timsort (вбудоване сортування Python):**
    - На впорядкованих даних: 0.000065
    - На зворотно впорядкованих даних: 0.000061
    - На випадкових даних: 0.00090

## Висновки

### Ефективність алгоритмів

- **Сортування злиттям:** Показало добрі результати на всіх типах даних, особливо ефективне на випадкових даних.
- **Сортування вставками:** Хороші результати на впорядкованих даних, але значно повільніше на великих об'ємах даних, особливо на випадкових або зворотно впорядкованих.
- **Timsort (вбудоване сортування Python):** Надзвичайно швидке на всіх типах даних. Показує найкращі результати завдяки оптимізаціям для різних типів даних.

### Застосування

- **Сортування злиттям** рекомендується для великих наборів даних, де стабільність сортування та швидкість є критичними.
- **Сортування вставками** є вибором для малих наборів даних або коли дані вже частково впорядковані.
- **Timsort** є найкращим вибором для загального використання в Python завдяки своїй високій продуктивності та ефективності на різних типах даних.

## Висновок

Емпіричний аналіз підтверджує, що Timsort є найефективнішим алгоритмом сортування для загального використання у Python. Це пояснює, чому цей алгоритм є вбудованим у Python і чому програмісти часто віддають перевагу використанню вбудованих функцій сортування замість написання власних алгоритмів.
